// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// APIDefinition APIDefinition represents the configuration for a single proxied API and it's versions.
//
// swagger:model APIDefinition
type APIDefinition struct {

	// API ID
	APIID string `json:"api_id,omitempty"`

	// active
	Active bool `json:"active,omitempty"`

	// allowed i ps
	AllowedIPs []string `json:"allowed_ips"`

	// auth configs
	AuthConfigs map[string]AuthConfig `json:"auth_configs,omitempty"`

	// blacklisted i ps
	BlacklistedIPs []string `json:"blacklisted_ips"`

	// c o r s
	CORS *APIDefinitionCORS `json:"CORS,omitempty"`

	// certificates
	Certificates []string `json:"certificates"`

	// client certificates
	ClientCertificates []string `json:"client_certificates"`

	// config data
	ConfigData interface{} `json:"config_data,omitempty"`

	// custom middleware bundle
	CustomMiddlewareBundle string `json:"custom_middleware_bundle,omitempty"`

	// disable quota
	DisableQuota bool `json:"disable_quota,omitempty"`

	// disable rate limit
	DisableRateLimit bool `json:"disable_rate_limit,omitempty"`

	// do not track
	DoNotTrack bool `json:"do_not_track,omitempty"`

	// domain
	Domain string `json:"domain,omitempty"`

	// dont set quotas on create
	DontSetQuotasOnCreate bool `json:"dont_set_quota_on_create,omitempty"`

	// enable batch request support
	EnableBatchRequestSupport bool `json:"enable_batch_request_support,omitempty"`

	// enable co process auth
	EnableCoProcessAuth bool `json:"enable_coprocess_auth,omitempty"`

	// enable context vars
	EnableContextVars bool `json:"enable_context_vars,omitempty"`

	// enable detailed recording
	EnableDetailedRecording bool `json:"enable_detailed_recording,omitempty"`

	// enable Ip blacklisting
	EnableIPBlacklisting bool `json:"enable_ip_blacklisting,omitempty"`

	// enable Ip white listing
	EnableIPWhiteListing bool `json:"enable_ip_whitelisting,omitempty"`

	// enable j w t
	EnableJWT bool `json:"enable_jwt,omitempty"`

	// enable proxy protocol
	EnableProxyProtocol bool `json:"enable_proxy_protocol,omitempty"`

	// enable signature checking
	EnableSignatureChecking bool `json:"enable_signature_checking,omitempty"`

	// expire analytics after
	ExpireAnalyticsAfter int64 `json:"expire_analytics_after,omitempty"`

	// hmac allowed algorithms
	HmacAllowedAlgorithms []string `json:"hmac_allowed_algorithms"`

	// hmac allowed clock skew
	HmacAllowedClockSkew float64 `json:"hmac_allowed_clock_skew,omitempty"`

	// Id
	ID string `json:"id,omitempty"`

	// internal
	Internal bool `json:"internal,omitempty"`

	// j w t client ID base field
	JWTClientIDBaseField string `json:"jwt_client_base_field,omitempty"`

	// j w t default policies
	JWTDefaultPolicies []string `json:"jwt_default_policies"`

	// j w t expires at validation skew
	JWTExpiresAtValidationSkew uint64 `json:"jwt_expires_at_validation_skew,omitempty"`

	// j w t identity base field
	JWTIdentityBaseField string `json:"jwt_identity_base_field,omitempty"`

	// j w t issued at validation skew
	JWTIssuedAtValidationSkew uint64 `json:"jwt_issued_at_validation_skew,omitempty"`

	// j w t not before validation skew
	JWTNotBeforeValidationSkew uint64 `json:"jwt_not_before_validation_skew,omitempty"`

	// j w t policy field name
	JWTPolicyFieldName string `json:"jwt_policy_field_name,omitempty"`

	// j w t scope claim name
	JWTScopeClaimName string `json:"jwt_scope_claim_name,omitempty"`

	// j w t scope to policy mapping
	JWTScopeToPolicyMapping map[string]string `json:"jwt_scope_to_policy_mapping,omitempty"`

	// j w t signing method
	JWTSigningMethod string `json:"jwt_signing_method,omitempty"`

	// j w t skip kid
	JWTSkipKid bool `json:"jwt_skip_kid,omitempty"`

	// j w t source
	JWTSource string `json:"jwt_source,omitempty"`

	// listen port
	ListenPort int64 `json:"listen_port,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// org ID
	OrgID string `json:"org_id,omitempty"`

	// pinned public keys
	PinnedPublicKeys map[string]string `json:"pinned_public_keys,omitempty"`

	// protocol
	Protocol string `json:"protocol,omitempty"`

	// response processors
	ResponseProcessors []*ResponseProcessor `json:"response_processors"`

	// session lifetime
	SessionLifetime int64 `json:"session_lifetime,omitempty"`

	// slug
	Slug string `json:"slug,omitempty"`

	// strip auth data
	StripAuthData bool `json:"strip_auth_data,omitempty"`

	// tag headers
	TagHeaders []string `json:"tag_headers"`

	// tags
	Tags []string `json:"tags"`

	// upstream certificates
	UpstreamCertificates map[string]string `json:"upstream_certificates,omitempty"`

	// use basic auth
	UseBasicAuth bool `json:"use_basic_auth,omitempty"`

	// use go plugin auth
	UseGoPluginAuth bool `json:"use_go_plugin_auth,omitempty"`

	// use keyless access
	UseKeylessAccess bool `json:"use_keyless,omitempty"`

	// use mutual TLS auth
	UseMutualTLSAuth bool `json:"use_mutual_tls_auth,omitempty"`

	// use oauth2
	UseOauth2 bool `json:"use_oauth2,omitempty"`

	// use open ID
	UseOpenID bool `json:"use_openid,omitempty"`

	// use standard auth
	UseStandardAuth bool `json:"use_standard_auth,omitempty"`

	// auth
	Auth *AuthConfig `json:"auth,omitempty"`

	// auth provider
	AuthProvider *AuthProviderMeta `json:"auth_provider,omitempty"`

	// base identity provided by
	BaseIdentityProvidedBy AuthTypeEnum `json:"base_identity_provided_by,omitempty"`

	// basic auth
	BasicAuth *BasicAuth `json:"basic_auth,omitempty"`

	// cache options
	CacheOptions *CacheOptions `json:"cache_options,omitempty"`

	// custom middleware
	CustomMiddleware *MiddlewareSection `json:"custom_middleware,omitempty"`

	// definition
	Definition *VersionDefinition `json:"definition,omitempty"`

	// event handlers
	EventHandlers *EventHandlerMetaConfig `json:"event_handlers,omitempty"`

	// global rate limit
	GlobalRateLimit *GlobalRateLimit `json:"global_rate_limit,omitempty"`

	// notifications
	Notifications *NotificationsManager `json:"notifications,omitempty"`

	// oauth meta
	OauthMeta *Oauth2Meta `json:"oauth_meta,omitempty"`

	// openid options
	OpenidOptions *OpenIDOptions `json:"openid_options,omitempty"`

	// proxy
	Proxy *Proxy `json:"proxy,omitempty"`

	// request signing
	RequestSigning *RequestSigningMeta `json:"request_signing,omitempty"`

	// session provider
	SessionProvider *SessionProviderMeta `json:"session_provider,omitempty"`

	// uptime tests
	UptimeTests *UptimeTests `json:"uptime_tests,omitempty"`

	// version data
	VersionData *VersionData `json:"version_data,omitempty"`
}

// Validate validates this API definition
func (m *APIDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthConfigs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCORS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseProcessors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBaseIdentityProvidedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBasicAuth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomMiddleware(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefinition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEventHandlers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlobalRateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotifications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOauthMeta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenidOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProxy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestSigning(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUptimeTests(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *APIDefinition) validateAuthConfigs(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthConfigs) { // not required
		return nil
	}

	for k := range m.AuthConfigs {

		if err := validate.Required("auth_configs"+"."+k, "body", m.AuthConfigs[k]); err != nil {
			return err
		}
		if val, ok := m.AuthConfigs[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auth_configs" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("auth_configs" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *APIDefinition) validateCORS(formats strfmt.Registry) error {
	if swag.IsZero(m.CORS) { // not required
		return nil
	}

	if m.CORS != nil {
		if err := m.CORS.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CORS")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CORS")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateResponseProcessors(formats strfmt.Registry) error {
	if swag.IsZero(m.ResponseProcessors) { // not required
		return nil
	}

	for i := 0; i < len(m.ResponseProcessors); i++ {
		if swag.IsZero(m.ResponseProcessors[i]) { // not required
			continue
		}

		if m.ResponseProcessors[i] != nil {
			if err := m.ResponseProcessors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("response_processors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("response_processors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *APIDefinition) validateAuth(formats strfmt.Registry) error {
	if swag.IsZero(m.Auth) { // not required
		return nil
	}

	if m.Auth != nil {
		if err := m.Auth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("auth")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateAuthProvider(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthProvider) { // not required
		return nil
	}

	if m.AuthProvider != nil {
		if err := m.AuthProvider.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auth_provider")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("auth_provider")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateBaseIdentityProvidedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.BaseIdentityProvidedBy) { // not required
		return nil
	}

	if err := m.BaseIdentityProvidedBy.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("base_identity_provided_by")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("base_identity_provided_by")
		}
		return err
	}

	return nil
}

func (m *APIDefinition) validateBasicAuth(formats strfmt.Registry) error {
	if swag.IsZero(m.BasicAuth) { // not required
		return nil
	}

	if m.BasicAuth != nil {
		if err := m.BasicAuth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("basic_auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("basic_auth")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateCacheOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.CacheOptions) { // not required
		return nil
	}

	if m.CacheOptions != nil {
		if err := m.CacheOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cache_options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cache_options")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateCustomMiddleware(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomMiddleware) { // not required
		return nil
	}

	if m.CustomMiddleware != nil {
		if err := m.CustomMiddleware.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("custom_middleware")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("custom_middleware")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateDefinition(formats strfmt.Registry) error {
	if swag.IsZero(m.Definition) { // not required
		return nil
	}

	if m.Definition != nil {
		if err := m.Definition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateEventHandlers(formats strfmt.Registry) error {
	if swag.IsZero(m.EventHandlers) { // not required
		return nil
	}

	if m.EventHandlers != nil {
		if err := m.EventHandlers.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("event_handlers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("event_handlers")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateGlobalRateLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.GlobalRateLimit) { // not required
		return nil
	}

	if m.GlobalRateLimit != nil {
		if err := m.GlobalRateLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("global_rate_limit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("global_rate_limit")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateNotifications(formats strfmt.Registry) error {
	if swag.IsZero(m.Notifications) { // not required
		return nil
	}

	if m.Notifications != nil {
		if err := m.Notifications.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notifications")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("notifications")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateOauthMeta(formats strfmt.Registry) error {
	if swag.IsZero(m.OauthMeta) { // not required
		return nil
	}

	if m.OauthMeta != nil {
		if err := m.OauthMeta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauth_meta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauth_meta")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateOpenidOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.OpenidOptions) { // not required
		return nil
	}

	if m.OpenidOptions != nil {
		if err := m.OpenidOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("openid_options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("openid_options")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateProxy(formats strfmt.Registry) error {
	if swag.IsZero(m.Proxy) { // not required
		return nil
	}

	if m.Proxy != nil {
		if err := m.Proxy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxy")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateRequestSigning(formats strfmt.Registry) error {
	if swag.IsZero(m.RequestSigning) { // not required
		return nil
	}

	if m.RequestSigning != nil {
		if err := m.RequestSigning.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("request_signing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("request_signing")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateSessionProvider(formats strfmt.Registry) error {
	if swag.IsZero(m.SessionProvider) { // not required
		return nil
	}

	if m.SessionProvider != nil {
		if err := m.SessionProvider.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("session_provider")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("session_provider")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateUptimeTests(formats strfmt.Registry) error {
	if swag.IsZero(m.UptimeTests) { // not required
		return nil
	}

	if m.UptimeTests != nil {
		if err := m.UptimeTests.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uptime_tests")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uptime_tests")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) validateVersionData(formats strfmt.Registry) error {
	if swag.IsZero(m.VersionData) { // not required
		return nil
	}

	if m.VersionData != nil {
		if err := m.VersionData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version_data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("version_data")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this API definition based on the context it is used
func (m *APIDefinition) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthConfigs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCORS(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResponseProcessors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthProvider(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBaseIdentityProvidedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBasicAuth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCacheOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomMiddleware(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefinition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEventHandlers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGlobalRateLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotifications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOauthMeta(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpenidOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProxy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRequestSigning(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSessionProvider(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUptimeTests(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersionData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *APIDefinition) contextValidateAuthConfigs(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.AuthConfigs {

		if val, ok := m.AuthConfigs[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *APIDefinition) contextValidateCORS(ctx context.Context, formats strfmt.Registry) error {

	if m.CORS != nil {

		if swag.IsZero(m.CORS) { // not required
			return nil
		}

		if err := m.CORS.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CORS")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CORS")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateResponseProcessors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResponseProcessors); i++ {

		if m.ResponseProcessors[i] != nil {

			if swag.IsZero(m.ResponseProcessors[i]) { // not required
				return nil
			}

			if err := m.ResponseProcessors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("response_processors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("response_processors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *APIDefinition) contextValidateAuth(ctx context.Context, formats strfmt.Registry) error {

	if m.Auth != nil {

		if swag.IsZero(m.Auth) { // not required
			return nil
		}

		if err := m.Auth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("auth")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateAuthProvider(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthProvider != nil {

		if swag.IsZero(m.AuthProvider) { // not required
			return nil
		}

		if err := m.AuthProvider.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auth_provider")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("auth_provider")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateBaseIdentityProvidedBy(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.BaseIdentityProvidedBy) { // not required
		return nil
	}

	if err := m.BaseIdentityProvidedBy.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("base_identity_provided_by")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("base_identity_provided_by")
		}
		return err
	}

	return nil
}

func (m *APIDefinition) contextValidateBasicAuth(ctx context.Context, formats strfmt.Registry) error {

	if m.BasicAuth != nil {

		if swag.IsZero(m.BasicAuth) { // not required
			return nil
		}

		if err := m.BasicAuth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("basic_auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("basic_auth")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateCacheOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.CacheOptions != nil {

		if swag.IsZero(m.CacheOptions) { // not required
			return nil
		}

		if err := m.CacheOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cache_options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cache_options")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateCustomMiddleware(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomMiddleware != nil {

		if swag.IsZero(m.CustomMiddleware) { // not required
			return nil
		}

		if err := m.CustomMiddleware.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("custom_middleware")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("custom_middleware")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateDefinition(ctx context.Context, formats strfmt.Registry) error {

	if m.Definition != nil {

		if swag.IsZero(m.Definition) { // not required
			return nil
		}

		if err := m.Definition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateEventHandlers(ctx context.Context, formats strfmt.Registry) error {

	if m.EventHandlers != nil {

		if swag.IsZero(m.EventHandlers) { // not required
			return nil
		}

		if err := m.EventHandlers.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("event_handlers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("event_handlers")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateGlobalRateLimit(ctx context.Context, formats strfmt.Registry) error {

	if m.GlobalRateLimit != nil {

		if swag.IsZero(m.GlobalRateLimit) { // not required
			return nil
		}

		if err := m.GlobalRateLimit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("global_rate_limit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("global_rate_limit")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateNotifications(ctx context.Context, formats strfmt.Registry) error {

	if m.Notifications != nil {

		if swag.IsZero(m.Notifications) { // not required
			return nil
		}

		if err := m.Notifications.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notifications")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("notifications")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateOauthMeta(ctx context.Context, formats strfmt.Registry) error {

	if m.OauthMeta != nil {

		if swag.IsZero(m.OauthMeta) { // not required
			return nil
		}

		if err := m.OauthMeta.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauth_meta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauth_meta")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateOpenidOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.OpenidOptions != nil {

		if swag.IsZero(m.OpenidOptions) { // not required
			return nil
		}

		if err := m.OpenidOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("openid_options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("openid_options")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateProxy(ctx context.Context, formats strfmt.Registry) error {

	if m.Proxy != nil {

		if swag.IsZero(m.Proxy) { // not required
			return nil
		}

		if err := m.Proxy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxy")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateRequestSigning(ctx context.Context, formats strfmt.Registry) error {

	if m.RequestSigning != nil {

		if swag.IsZero(m.RequestSigning) { // not required
			return nil
		}

		if err := m.RequestSigning.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("request_signing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("request_signing")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateSessionProvider(ctx context.Context, formats strfmt.Registry) error {

	if m.SessionProvider != nil {

		if swag.IsZero(m.SessionProvider) { // not required
			return nil
		}

		if err := m.SessionProvider.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("session_provider")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("session_provider")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateUptimeTests(ctx context.Context, formats strfmt.Registry) error {

	if m.UptimeTests != nil {

		if swag.IsZero(m.UptimeTests) { // not required
			return nil
		}

		if err := m.UptimeTests.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uptime_tests")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uptime_tests")
			}
			return err
		}
	}

	return nil
}

func (m *APIDefinition) contextValidateVersionData(ctx context.Context, formats strfmt.Registry) error {

	if m.VersionData != nil {

		if swag.IsZero(m.VersionData) { // not required
			return nil
		}

		if err := m.VersionData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version_data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("version_data")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *APIDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *APIDefinition) UnmarshalBinary(b []byte) error {
	var res APIDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BasicAuth basic auth
//
// swagger:model BasicAuth
type BasicAuth struct {

	// body password regexp
	BodyPasswordRegexp string `json:"body_password_regexp,omitempty"`

	// body user regexp
	BodyUserRegexp string `json:"body_user_regexp,omitempty"`

	// cache TTL
	CacheTTL int64 `json:"cache_ttl,omitempty"`

	// disable caching
	DisableCaching bool `json:"disable_caching,omitempty"`

	// extract from body
	ExtractFromBody bool `json:"extract_from_body,omitempty"`
}

// Validate validates this basic auth
func (m *BasicAuth) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this basic auth based on context it is used
func (m *BasicAuth) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BasicAuth) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BasicAuth) UnmarshalBinary(b []byte) error {
	var res BasicAuth
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// APIDefinitionCORS API definition c o r s
//
// swagger:model APIDefinitionCORS
type APIDefinitionCORS struct {

	// allow credentials
	AllowCredentials bool `json:"allow_credentials,omitempty"`

	// allowed headers
	AllowedHeaders []string `json:"allowed_headers"`

	// allowed methods
	AllowedMethods []string `json:"allowed_methods"`

	// allowed origins
	AllowedOrigins []string `json:"allowed_origins"`

	// debug
	Debug bool `json:"debug,omitempty"`

	// enable
	Enable bool `json:"enable,omitempty"`

	// exposed headers
	ExposedHeaders []string `json:"exposed_headers"`

	// max age
	MaxAge int64 `json:"max_age,omitempty"`

	// options passthrough
	OptionsPassthrough bool `json:"options_passthrough,omitempty"`
}

// Validate validates this API definition c o r s
func (m *APIDefinitionCORS) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this API definition c o r s based on context it is used
func (m *APIDefinitionCORS) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *APIDefinitionCORS) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *APIDefinitionCORS) UnmarshalBinary(b []byte) error {
	var res APIDefinitionCORS
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VersionDefinition version definition
//
// swagger:model VersionDefinition
type VersionDefinition struct {

	// key
	Key string `json:"key,omitempty"`

	// location
	Location string `json:"location,omitempty"`

	// strip path
	StripPath bool `json:"strip_path,omitempty"`
}

// Validate validates this version definition
func (m *VersionDefinition) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this version definition based on context it is used
func (m *VersionDefinition) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VersionDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VersionDefinition) UnmarshalBinary(b []byte) error {
	var res VersionDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Oauth2Meta oauth2 meta
//
// swagger:model Oauth2Meta
type Oauth2Meta struct {

	// allowed access types
	AllowedAccessTypes []AccessRequestType `json:"allowed_access_types"`

	// allowed authorize types
	AllowedAuthorizeTypes []AuthorizeRequestType `json:"allowed_authorize_types"`

	// authorize login redirect
	AuthorizeLoginRedirect string `json:"auth_login_redirect,omitempty"`
}

// Validate validates this oauth2 meta
func (m *Oauth2Meta) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAllowedAccessTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowedAuthorizeTypes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Oauth2Meta) validateAllowedAccessTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowedAccessTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.AllowedAccessTypes); i++ {

		if err := m.AllowedAccessTypes[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauth_meta" + "." + "allowed_access_types" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauth_meta" + "." + "allowed_access_types" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *Oauth2Meta) validateAllowedAuthorizeTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowedAuthorizeTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.AllowedAuthorizeTypes); i++ {

		if err := m.AllowedAuthorizeTypes[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauth_meta" + "." + "allowed_authorize_types" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauth_meta" + "." + "allowed_authorize_types" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this oauth2 meta based on the context it is used
func (m *Oauth2Meta) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAllowedAccessTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAllowedAuthorizeTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Oauth2Meta) contextValidateAllowedAccessTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AllowedAccessTypes); i++ {

		if swag.IsZero(m.AllowedAccessTypes[i]) { // not required
			return nil
		}

		if err := m.AllowedAccessTypes[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauth_meta" + "." + "allowed_access_types" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauth_meta" + "." + "allowed_access_types" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *Oauth2Meta) contextValidateAllowedAuthorizeTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AllowedAuthorizeTypes); i++ {

		if swag.IsZero(m.AllowedAuthorizeTypes[i]) { // not required
			return nil
		}

		if err := m.AllowedAuthorizeTypes[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauth_meta" + "." + "allowed_authorize_types" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauth_meta" + "." + "allowed_authorize_types" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Oauth2Meta) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Oauth2Meta) UnmarshalBinary(b []byte) error {
	var res Oauth2Meta
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Proxy proxy
//
// swagger:model Proxy
type Proxy struct {

	// check host against uptime tests
	CheckHostAgainstUptimeTests bool `json:"check_host_against_uptime_tests,omitempty"`

	// disable strip slash
	DisableStripSlash bool `json:"disable_strip_slash,omitempty"`

	// enable load balancing
	EnableLoadBalancing bool `json:"enable_load_balancing,omitempty"`

	// listen path
	ListenPath string `json:"listen_path,omitempty"`

	// preserve host header
	PreserveHostHeader bool `json:"preserve_host_header,omitempty"`

	// strip listen path
	StripListenPath bool `json:"strip_listen_path,omitempty"`

	// target URL
	TargetURL string `json:"target_url,omitempty"`

	// targets
	Targets []string `json:"target_list"`

	// service discovery
	ServiceDiscovery *ServiceDiscoveryConfiguration `json:"service_discovery,omitempty"`

	// transport
	Transport *Transport `json:"transport,omitempty"`
}

// Validate validates this proxy
func (m *Proxy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateServiceDiscovery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransport(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Proxy) validateServiceDiscovery(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceDiscovery) { // not required
		return nil
	}

	if m.ServiceDiscovery != nil {
		if err := m.ServiceDiscovery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxy" + "." + "service_discovery")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxy" + "." + "service_discovery")
			}
			return err
		}
	}

	return nil
}

func (m *Proxy) validateTransport(formats strfmt.Registry) error {
	if swag.IsZero(m.Transport) { // not required
		return nil
	}

	if m.Transport != nil {
		if err := m.Transport.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxy" + "." + "transport")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxy" + "." + "transport")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this proxy based on the context it is used
func (m *Proxy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateServiceDiscovery(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransport(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Proxy) contextValidateServiceDiscovery(ctx context.Context, formats strfmt.Registry) error {

	if m.ServiceDiscovery != nil {

		if swag.IsZero(m.ServiceDiscovery) { // not required
			return nil
		}

		if err := m.ServiceDiscovery.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxy" + "." + "service_discovery")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxy" + "." + "service_discovery")
			}
			return err
		}
	}

	return nil
}

func (m *Proxy) contextValidateTransport(ctx context.Context, formats strfmt.Registry) error {

	if m.Transport != nil {

		if swag.IsZero(m.Transport) { // not required
			return nil
		}

		if err := m.Transport.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxy" + "." + "transport")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxy" + "." + "transport")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Proxy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Proxy) UnmarshalBinary(b []byte) error {
	var res Proxy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Transport transport
//
// swagger:model Transport
type Transport struct {

	// proxy URL
	ProxyURL string `json:"proxy_url,omitempty"`

	// s s l cipher suites
	SSLCipherSuites []string `json:"ssl_ciphers"`

	// s s l force common name check
	SSLForceCommonNameCheck bool `json:"ssl_force_common_name_check,omitempty"`

	// s s l insecure skip verify
	SSLInsecureSkipVerify bool `json:"ssl_insecure_skip_verify,omitempty"`

	// s s l min version
	SSLMinVersion uint16 `json:"ssl_min_version,omitempty"`
}

// Validate validates this transport
func (m *Transport) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this transport based on context it is used
func (m *Transport) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Transport) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Transport) UnmarshalBinary(b []byte) error {
	var res Transport
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// UptimeTests uptime tests
//
// swagger:model UptimeTests
type UptimeTests struct {

	// check list
	CheckList []*HostCheckObject `json:"check_list"`

	// config
	Config *Config `json:"config,omitempty"`
}

// Validate validates this uptime tests
func (m *UptimeTests) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCheckList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UptimeTests) validateCheckList(formats strfmt.Registry) error {
	if swag.IsZero(m.CheckList) { // not required
		return nil
	}

	for i := 0; i < len(m.CheckList); i++ {
		if swag.IsZero(m.CheckList[i]) { // not required
			continue
		}

		if m.CheckList[i] != nil {
			if err := m.CheckList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("uptime_tests" + "." + "check_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("uptime_tests" + "." + "check_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UptimeTests) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.Config) { // not required
		return nil
	}

	if m.Config != nil {
		if err := m.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uptime_tests" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uptime_tests" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this uptime tests based on the context it is used
func (m *UptimeTests) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCheckList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UptimeTests) contextValidateCheckList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CheckList); i++ {

		if m.CheckList[i] != nil {

			if swag.IsZero(m.CheckList[i]) { // not required
				return nil
			}

			if err := m.CheckList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("uptime_tests" + "." + "check_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("uptime_tests" + "." + "check_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UptimeTests) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.Config != nil {

		if swag.IsZero(m.Config) { // not required
			return nil
		}

		if err := m.Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uptime_tests" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uptime_tests" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UptimeTests) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UptimeTests) UnmarshalBinary(b []byte) error {
	var res UptimeTests
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Config config
//
// swagger:model Config
type Config struct {

	// expire uptime analytics after
	ExpireUptimeAnalyticsAfter int64 `json:"expire_utime_after,omitempty"`

	// recheck wait
	RecheckWait int64 `json:"recheck_wait,omitempty"`

	// service discovery
	ServiceDiscovery *ServiceDiscoveryConfiguration `json:"service_discovery,omitempty"`
}

// Validate validates this config
func (m *Config) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateServiceDiscovery(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Config) validateServiceDiscovery(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceDiscovery) { // not required
		return nil
	}

	if m.ServiceDiscovery != nil {
		if err := m.ServiceDiscovery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uptime_tests" + "." + "config" + "." + "service_discovery")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uptime_tests" + "." + "config" + "." + "service_discovery")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this config based on the context it is used
func (m *Config) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateServiceDiscovery(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Config) contextValidateServiceDiscovery(ctx context.Context, formats strfmt.Registry) error {

	if m.ServiceDiscovery != nil {

		if swag.IsZero(m.ServiceDiscovery) { // not required
			return nil
		}

		if err := m.ServiceDiscovery.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uptime_tests" + "." + "config" + "." + "service_discovery")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uptime_tests" + "." + "config" + "." + "service_discovery")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Config) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Config) UnmarshalBinary(b []byte) error {
	var res Config
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VersionData version data
//
// swagger:model VersionData
type VersionData struct {

	// default version
	DefaultVersion string `json:"default_version,omitempty"`

	// not versioned
	NotVersioned bool `json:"not_versioned,omitempty"`

	// versions
	Versions map[string]VersionInfo `json:"versions,omitempty"`
}

// Validate validates this version data
func (m *VersionData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateVersions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VersionData) validateVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.Versions) { // not required
		return nil
	}

	for k := range m.Versions {

		if err := validate.Required("version_data"+"."+"versions"+"."+k, "body", m.Versions[k]); err != nil {
			return err
		}
		if val, ok := m.Versions[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("version_data" + "." + "versions" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("version_data" + "." + "versions" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this version data based on the context it is used
func (m *VersionData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VersionData) contextValidateVersions(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Versions {

		if val, ok := m.Versions[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VersionData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VersionData) UnmarshalBinary(b []byte) error {
	var res VersionData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
