// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RoutingTriggerOptions routing trigger options
//
// swagger:model RoutingTriggerOptions
type RoutingTriggerOptions struct {

	// header matches
	HeaderMatches map[string]StringRegexMap `json:"header_matches,omitempty"`

	// path part matches
	PathPartMatches map[string]StringRegexMap `json:"path_part_matches,omitempty"`

	// query val matches
	QueryValMatches map[string]StringRegexMap `json:"query_val_matches,omitempty"`

	// request context matches
	RequestContextMatches map[string]StringRegexMap `json:"request_context_matches,omitempty"`

	// session meta matches
	SessionMetaMatches map[string]StringRegexMap `json:"session_meta_matches,omitempty"`

	// payload matches
	PayloadMatches *StringRegexMap `json:"payload_matches,omitempty"`
}

// Validate validates this routing trigger options
func (m *RoutingTriggerOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHeaderMatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePathPartMatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryValMatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestContextMatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionMetaMatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePayloadMatches(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RoutingTriggerOptions) validateHeaderMatches(formats strfmt.Registry) error {
	if swag.IsZero(m.HeaderMatches) { // not required
		return nil
	}

	for k := range m.HeaderMatches {

		if err := validate.Required("header_matches"+"."+k, "body", m.HeaderMatches[k]); err != nil {
			return err
		}
		if val, ok := m.HeaderMatches[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("header_matches" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("header_matches" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) validatePathPartMatches(formats strfmt.Registry) error {
	if swag.IsZero(m.PathPartMatches) { // not required
		return nil
	}

	for k := range m.PathPartMatches {

		if err := validate.Required("path_part_matches"+"."+k, "body", m.PathPartMatches[k]); err != nil {
			return err
		}
		if val, ok := m.PathPartMatches[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("path_part_matches" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("path_part_matches" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) validateQueryValMatches(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryValMatches) { // not required
		return nil
	}

	for k := range m.QueryValMatches {

		if err := validate.Required("query_val_matches"+"."+k, "body", m.QueryValMatches[k]); err != nil {
			return err
		}
		if val, ok := m.QueryValMatches[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("query_val_matches" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("query_val_matches" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) validateRequestContextMatches(formats strfmt.Registry) error {
	if swag.IsZero(m.RequestContextMatches) { // not required
		return nil
	}

	for k := range m.RequestContextMatches {

		if err := validate.Required("request_context_matches"+"."+k, "body", m.RequestContextMatches[k]); err != nil {
			return err
		}
		if val, ok := m.RequestContextMatches[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("request_context_matches" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("request_context_matches" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) validateSessionMetaMatches(formats strfmt.Registry) error {
	if swag.IsZero(m.SessionMetaMatches) { // not required
		return nil
	}

	for k := range m.SessionMetaMatches {

		if err := validate.Required("session_meta_matches"+"."+k, "body", m.SessionMetaMatches[k]); err != nil {
			return err
		}
		if val, ok := m.SessionMetaMatches[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("session_meta_matches" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("session_meta_matches" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) validatePayloadMatches(formats strfmt.Registry) error {
	if swag.IsZero(m.PayloadMatches) { // not required
		return nil
	}

	if m.PayloadMatches != nil {
		if err := m.PayloadMatches.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payload_matches")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payload_matches")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this routing trigger options based on the context it is used
func (m *RoutingTriggerOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHeaderMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePathPartMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryValMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRequestContextMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSessionMetaMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePayloadMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RoutingTriggerOptions) contextValidateHeaderMatches(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.HeaderMatches {

		if val, ok := m.HeaderMatches[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) contextValidatePathPartMatches(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.PathPartMatches {

		if val, ok := m.PathPartMatches[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) contextValidateQueryValMatches(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.QueryValMatches {

		if val, ok := m.QueryValMatches[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) contextValidateRequestContextMatches(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.RequestContextMatches {

		if val, ok := m.RequestContextMatches[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) contextValidateSessionMetaMatches(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.SessionMetaMatches {

		if val, ok := m.SessionMetaMatches[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *RoutingTriggerOptions) contextValidatePayloadMatches(ctx context.Context, formats strfmt.Registry) error {

	if m.PayloadMatches != nil {

		if swag.IsZero(m.PayloadMatches) { // not required
			return nil
		}

		if err := m.PayloadMatches.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payload_matches")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payload_matches")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RoutingTriggerOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RoutingTriggerOptions) UnmarshalBinary(b []byte) error {
	var res RoutingTriggerOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
